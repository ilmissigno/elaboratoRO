(! Orienteering Problem
i vincoli di grado 2 dipendono dalla selezioe del nodo
rompo i cicli nel modo seguente: tutti quelli da 3 senza il nodo 1, 
poichè il nodo 1 deve essere connesso al resto della soluzione,
rompo i cicli da 3 cui appartiene il nodo 1 se ne  resta fuori un nodo selezionato
!)

model "OP"

uses "mmxprs"
(!
  setparam("XPRS_VERBOSE",true)    ! Enable message printing in mmxprs
  setparam("XPRS_CUTSTRATEGY",0)   ! Disable automatic cuts 
  setparam("XPRS_HEURSTRATEGY",0)  ! Disable MIP heuristics 
  setparam("XPRS_PRESOLVE",0)      ! Switch off presolve 
!)
 
declarations
DurataCiclo : mpvar
Tmax : integer           ! durata massima del tour
n_nodi = 7               ! il nodo 1 è il punto di inizio, sempre presente
NODI = 1..n_nodi         ! Index range per i nodi
reward : array (NODI) of integer ! vettore con l'attrattivita' dei posti
grado : array (NODI) of linctr
ARCHI : dynamic array (NODI, NODI) of integer
COSTI : dynamic array (NODI, NODI) of integer 
x: dynamic array(NODI, NODI)of mpvar !variabili decisionali x_ij
y:array (NODI) of mpvar  ! y(i)=1 se il nodo i fa parte del tour
end-declarations

forward procedure stampa

initializations from "Graph.dat" ! vedi dati a fine file
ARCHI
COSTI
Tmax
reward
end-initializations

! dichiaro x(ij) solo per i<j e solo se l'arco esiste in ARCHI 
forall (i in NODI,j in NODI | i<j and  ARCHI(i,j)=1 ) create(x(i,j))

forall (i in NODI, j in NODI )x(i,j) is_binary
forall (i in NODI) y(i) is_binary

! ogni nodo i selezionato ha 2 archi incidenti 
forall (i in NODI ) grado(i) := (sum(j in NODI) x(i,j) + sum(h in NODI) x(h,i)) = 2 * y(i)


DurataCiclo = sum (i in NODI,j in NODI) COSTI(i,j) * x(i,j) 
DurataCiclo <= Tmax

y(1) = 1  ! ogni ciclo contiene il nodo 1

! nel caso generale di n nodi, devo inserire tutti i vincoli violati di subtour breaking
! così fatti: perogni V in N: 1 in V, somma  archi in G(V) <= |V|-y_j perogni j nonin V.
! vieto i tour fatti solo su V se fuori V c'è un nodo selezionato.
! Inoltre vieto tutti i subtour che non includono 1
! poichè qui ho 7 nodi, qualsiasi soluzione non ammissibile ha almeno un ciclo da 3
! (non ci sono cicli da 2, essendoci solo x(ij) e non x(ji))

! subtour breaking dei cicli da 3 nodi non incidenti sul nodo 1
forall (i,j,k in NODI | i<>1 and i<j and j<k) x(i,j)+x(j,k)+x(i,k) <=2
! taglia i cicli da 3 col nodo 1 se c'è un altro nodo selezionato non parte del ciclo
forall (i,j,k in NODI | 
	    j<k and i>1 and  i<>j and i<>k) x(1,j)+x(j,k)+x(1,k) <= 3 - y(i) 
	    !j<k ) x(1,j)+x(j,k)+x(1,k) <= 3 - y(i) 

cyclereward := sum (i in NODI) reward(i)*y(i)
maximize (cyclereward); 
stampa

procedure stampa
writeln ("durata soluzione ",getsol(DurataCiclo), "\narchi presenti:")
forall (i in NODI, j in NODI | getsol(x(i,j)) <>0) 
  writeln("\t(",i,",",j,") di durata ", COSTI(i,j) ) 
writeln("\nnodi presenti: ")
forall (i in NODI | getsol(y(i)) <>0) writeln("\tnodo ",i," reward ",reward(i))
writeln("reward totale = ", getobjval)
end-procedure
 
end-model

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
contenuto del file dei dati Graph.dat

ARCHI : [ (1 2) 1 (1 3) 1  (1 4) 1  (1 5) 1  (1 6) 1  (1 7) 1
		          (2 3) 1  (2 4) 1  (2 5) 1  (2 6) 1  (2 7) 1
		  	 			   (3 4) 1  (3 5) 1  (3 6) 1  (3 7) 1
									(4 5) 1  (4 6) 1  (4 7) 1
									 		 (5 6) 1  (5 7) 1
													  (6 7) 1 ]

COSTI : [ (1 2) 1  (1 3) 1 (1 4) 20 (1 5) 20 (1 6) 20 (1 7) 12
		 		   (2 3) 1 (2 4) 12 (2 5) 20 (2 6) 20 (2 7) 20
		  				   (3 4) 11 (3 5) 3  (3 6) 20 (3 7) 9
		  						    (4 5) 11 (4 6) 10 (4 7) 20
											 (5 6) 6  (5 7) 7
												      (6 7) 9 ]

Tmax : 41 ! è < del tsp con tutti i nodi che vale 43

reward : [ 13,  6,  12,  17,  21,  15,  8]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

soluzione OP ottimo:
durata 33, reward 84
archi:
	(1,2) di durata 1
	(1,3) di durata 1
	(2,4) di durata 12
	(3,5) di durata 3
	(4,6) di durata 10
	(5,6) di durata 6

nodi: 
	nodo 1 reward 13
	nodo 2 reward 6
	nodo 3 reward 12
	nodo 4 reward 17
	nodo 5 reward 21
	nodo 6 reward 15
